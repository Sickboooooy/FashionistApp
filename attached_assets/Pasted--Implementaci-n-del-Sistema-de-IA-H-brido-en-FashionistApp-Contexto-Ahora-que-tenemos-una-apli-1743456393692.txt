# Implementación del Sistema de IA Híbrido en FashionistApp

## Contexto

Ahora que tenemos una aplicación funcional con generación de outfits básica y visualización tipo revista, vamos a mejorar significativamente la inteligencia de la aplicación implementando un sistema híbrido que utilice las diferentes APIs que ya tenemos configuradas en los secretos de Replit.

## Objetivo

Implementar un servicio híbrido de IA que utilice:
1. **Gemini** para análisis visual de prendas
2. **Claude** para análisis contextual y preferencias
3. **OpenAI GPT-4** para generación de outfits y contenido editorial
4. Configuración de fallbacks para garantizar la robustez del sistema

## Implementación: Paso a Paso

### 1. Estructura del Servicio de IA Híbrido

Primero, vamos a crear un nuevo servicio que gestione todas las operaciones de IA:

```javascript
// server/services/aiService.js
const axios = require('axios');
const { OpenAI } = require('openai');

class AIService {
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  async analyzeGarmentImage(imageBuffer) {
    console.log("Analizando imagen con Gemini...");
    try {
      // Convertir a base64
      const base64Image = imageBuffer.toString('base64');
      
      // Llamada a Gemini para análisis de imagen
      const response = await axios.post(
        'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent',
        {
          contents: [{
            parts: [
              { text: "Analiza esta prenda de ropa en detalle y proporciona los siguientes datos en formato JSON: tipo de prenda, color principal, estilo, material aparente, ocasiones apropiadas (array) y temporada. No incluyas texto explicativo fuera del JSON." },
              { inlineData: { data: base64Image, mimeType: "image/jpeg" } }
            ]
          }]
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'x-goog-api-key': process.env.GEMINI_API_KEY
          }
        }
      );
      
      // Extraer el JSON de la respuesta
      const content = response.data.candidates[0].content.parts[0].text;
      let jsonData;
      
      try {
        // Intentar extraer JSON si está en formato código
        const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) || 
                          content.match(/```\n([\s\S]*?)\n```/) ||
                          content.match(/{[\s\S]*?}/);
                          
        jsonData = jsonMatch 
          ? JSON.parse(jsonMatch[1] || jsonMatch[0]) 
          : { error: "No se pudo extraer JSON" };
      } catch (parseError) {
        console.error("Error parseando respuesta de Gemini:", parseError);
        // Fallback a respuesta cruda
        jsonData = { 
          rawResponse: content,
          error: "Error de formato en la respuesta"
        };
      }
      
      return jsonData;
      
    } catch (error) {
      console.error("Error en análisis de imagen con Gemini:", error);
      // Fallback a OpenAI
      console.log("Utilizando fallback con OpenAI...");
      return this.fallbackImageAnalysis(imageBuffer);
    }
  }

  async analyzeUserStyle(userPreferences, occasion = null) {
    console.log("Analizando estilo con Claude...");
    try {
      // Preparar prompt para Claude
      const promptText = `Analiza las siguientes preferencias de usuario para generar recomendaciones de estilo${occasion ? ` para la ocasión "${occasion}"` : ''}.
      
      Preferencias del usuario:
      ${JSON.stringify(userPreferences, null, 2)}
      
      Analiza estas preferencias y devuelve un objeto JSON con:
      - styleElements: Array con los elementos de estilo clave a priorizar
      - colorPalette: Array con colores recomendados (nombres y códigos hex) 
      - avoidStyles: Array con estilos a evitar
      - focusPoints: Array con puntos de enfoque para los outfits
      - rationale: Texto explicando el análisis realizado
      
      Responde ÚNICAMENTE con el objeto JSON, sin texto adicional.`;
      
      // Llamada a Claude
      const response = await axios.post(
        'https://api.anthropic.com/v1/messages',
        {
          model: "claude-3-haiku-20240307",
          max_tokens: 1000,
          messages: [
            { role: "user", content: promptText }
          ]
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': process.env.CLAUDE_API_KEY,
            'anthropic-version': '2023-06-01'
          }
        }
      );
      
      // Extraer el contenido de la respuesta
      const content = response.data.content[0].text;
      let jsonData;
      
      try {
        // Intentar extraer JSON si está en formato código
        const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) || 
                          content.match(/```\n([\s\S]*?)\n```/) ||
                          content.match(/{[\s\S]*?}/);
                          
        jsonData = jsonMatch 
          ? JSON.parse(jsonMatch[1] || jsonMatch[0]) 
          : { error: "No se pudo extraer JSON" };
      } catch (parseError) {
        console.error("Error parseando respuesta de Claude:", parseError);
        // Fallback a respuesta cruda
        jsonData = { 
          rawResponse: content,
          error: "Error de formato en la respuesta"
        };
      }
      
      return jsonData;
      
    } catch (error) {
      console.error("Error en análisis de estilo con Claude:", error);
      // Fallback a OpenAI
      console.log("Utilizando fallback con OpenAI...");
      return this.fallbackStyleAnalysis(userPreferences, occasion);
    }
  }

  async generateOutfits(garmentData, stylePreferences, count = 3) {
    console.log("Generando outfits con OpenAI...");
    try {
      const response = await this.openai.chat.completions.create({
        model: "gpt-4-turbo",
        messages: [
          {
            role: "system",
            content: "Eres un estilista de moda de élite que crea outfits personalizados basados en prendas y preferencias. Respondes siempre con JSON estructurado."
          },
          {
            role: "user",
            content: `Genera ${count} outfits completos basados en esta prenda:
            
            ${JSON.stringify(garmentData, null, 2)}
            
            Y considerando estas preferencias de estilo:
            
            ${JSON.stringify(stylePreferences, null, 2)}
            
            Devuelve un objeto JSON con un array 'outfits', donde cada elemento del array contiene:
            {
              "id": número único,
              "name": nombre creativo del outfit,
              "items": array con todas las prendas y accesorios (incluyendo la prenda original),
              "occasion": ocasión ideal,
              "style": estilo general,
              "stylingTip": consejo de estilismo
            }
            
            Asegúrate de que la respuesta sea SOLAMENTE un objeto JSON válido sin explicaciones adicionales.`
          }
        ],
        response_format: { type: "json_object" }
      });
      
      const result = JSON.parse(response.choices[0].message.content);
      return result;
      
    } catch (error) {
      console.error("Error generando outfits:", error);
      // En este caso no tenemos fallback, reportamos el error
      throw new Error(`Error generando outfits: ${error.message}`);
    }
  }
  
  async generateMagazineContent(outfits, templateStyle) {
    console.log("Generando contenido editorial para revista...");
    try {
      const styleGuide = {
        'vogue': 'elegante, sofisticado, minimalista con lenguaje refinado',
        'elle': 'moderno, juvenil, dinámico con lenguaje accesible',
        'bazaar': 'lujoso, detallado con lenguaje poético y referencias artísticas',
        'vanity': 'audaz, dramático con lenguaje impactante',
        'custom': 'artesanal, personalizado con referencias a técnicas manuales y diseños únicos'
      };
      
      const response = await this.openai.chat.completions.create({
        model: "gpt-4",
        messages: [
          {
            role: "system",
            content: `Eres un editor de moda de élite para la revista ${templateStyle.toUpperCase()}. Creas contenido editorial sofisticado y elegante.`
          },
          {
            role: "user",
            content: `Crea un artículo editorial de moda de dos páginas basado en los siguientes outfits:
            
            ${JSON.stringify(outfits, null, 2)}
            
            El estilo editorial debe ser ${styleGuide[templateStyle] || 'elegante y sofisticado'}.
            
            Incluye:
            1. Un título impactante para el artículo
            2. Una introducción cautivadora
            3. Descripción editorial de cada outfit con lenguaje de revista de moda
            4. Consejos de accesorios y estilismo
            5. Un párrafo de cierre inspirador
            
            Formatea la respuesta en HTML con las siguientes secciones:
            <div class="magazine-title">TÍTULO</div>
            <div class="magazine-intro">INTRODUCCIÓN</div>
            <div class="outfit-section">
              <div class="outfit-number">Outfit X</div>
              <div class="outfit-description">DESCRIPCIÓN</div>
              <div class="styling-tips">CONSEJOS</div>
            </div>
            ... (repetir para cada outfit)
            <div class="magazine-closing">CIERRE</div>`
          }
        ],
        max_tokens: 1500
      });
      
      return response.choices[0].message.content;
      
    } catch (error) {
      console.error("Error generando contenido de revista:", error);
      throw new Error(`Error generando contenido editorial: ${error.message}`);
    }
  }

  // MÉTODOS DE FALLBACK

  async fallbackImageAnalysis(imageBuffer) {
    console.log("Ejecutando fallback de análisis de imagen con OpenAI...");
    try {
      const base64Image = imageBuffer.toString('base64');
      
      const response = await this.openai.chat.completions.create({
        model: "gpt-4-vision-preview",
        messages: [
          {
            role: "system",
            content: "Analiza imágenes de prendas de ropa proporcionando detalles en formato JSON."
          },
          {
            role: "user",
            content: [
              {
                type: "text",
                text: "Analiza esta prenda de ropa y proporciona los siguientes datos en formato JSON: tipo de prenda, color principal, estilo, material aparente, ocasiones apropiadas (array) y temporada. Responde SOLO con el JSON."
              },
              {
                type: "image_url",
                image_url: {
                  url: `data:image/jpeg;base64,${base64Image}`
                }
              }
            ]
          }
        ],
        max_tokens: 800
      });
      
      // Extraer el contenido
      const content = response.choices[0].message.content;
      
      try {
        // Intentar extraer JSON si está en formato código
        const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) || 
                         content.match(/```\n([\s\S]*?)\n```/) ||
                         content.match(/{[\s\S]*?}/);
                         
        const jsonData = jsonMatch 
          ? JSON.parse(jsonMatch[1] || jsonMatch[0]) 
          : { error: "No se pudo extraer JSON" };
          
        return jsonData;
      } catch (parseError) {
        console.error("Error parseando respuesta de OpenAI Vision:", parseError);
        return {
          error: "Error procesando la respuesta",
          rawResponse: content
        };
      }
      
    } catch (error) {
      console.error("Error en el fallback de análisis de imagen:", error);
      // En este punto, ambos servicios fallaron, devolvemos un objeto con datos mínimos
      return {
        type: "No identificado",
        color: "No identificado",
        style: "Casual",
        material: "No identificado",
        occasions: ["Casual"],
        season: "All season",
        error: "Análisis fallido en múltiples servicios"
      };
    }
  }

  async fallbackStyleAnalysis(userPreferences, occasion = null) {
    console.log("Ejecutando fallback de análisis de estilo con OpenAI...");
    try {
      const response = await this.openai.chat.completions.create({
        model: "gpt-4-turbo",
        messages: [
          {
            role: "system",
            content: "Analiza preferencias de usuario para generar recomendaciones de moda en formato JSON."
          },
          {
            role: "user",
            content: `Analiza las siguientes preferencias de usuario para generar recomendaciones de estilo${occasion ? ` para la ocasión "${occasion}"` : ''}.
            
            Preferencias del usuario:
            ${JSON.stringify(userPreferences, null, 2)}
            
            Devuelve un objeto JSON con:
            - styleElements: Array con los elementos de estilo clave a priorizar
            - colorPalette: Array con colores recomendados (nombres y códigos hex)
            - avoidStyles: Array con estilos a evitar
            - focusPoints: Array con puntos de enfoque para los outfits
            - rationale: Texto explicando el análisis realizado
            
            Responde ÚNICAMENTE con el objeto JSON, sin texto adicional.`
          }
        ],
        response_format: { type: "json_object" }
      });
      
      return JSON.parse(response.choices[0].message.content);
      
    } catch (error) {
      console.error("Error en el fallback de análisis de estilo:", error);
      // Ambos servicios fallaron, devolvemos datos genéricos
      return {
        styleElements: ["Elegante", "Versátil", "Moderno"],
        colorPalette: ["Negro (#000000)", "Blanco (#FFFFFF)", "Azul marino (#000080)", "Beige (#F5F5DC)"],
        avoidStyles: ["Excesivamente casual", "Demasiado llamativo"],
        focusPoints: ["Silueta favorecedora", "Combinar con básicos"],
        rationale: "Recomendaciones genéricas basadas en principios universales de moda.",
        error: "Análisis fallido en múltiples servicios"
      };
    }
  }
  
  // Verificar que todas las API keys estén configuradas
  async verifyApiKeys() {
    const results = {
      openai: false,
      gemini: false,
      claude: false,
      allValid: false
    };
    
    console.log("Verificando API keys...");
    
    // Verificar OpenAI
    try {
      const openaiResponse = await this.openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: "Test" }],
        max_tokens: 5
      });
      results.openai = !!openaiResponse.choices;
    } catch (error) {
      console.error("Error verificando API key de OpenAI:", error.message);
    }
    
    // Verificar Gemini
    try {
      const geminiResponse = await axios.post(
        'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent',
        {
          contents: [{ parts: [{ text: "Test" }] }]
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'x-goog-api-key': process.env.GEMINI_API_KEY
          }
        }
      );
      results.gemini = !!geminiResponse.data;
    } catch (error) {
      console.error("Error verificando API key de Gemini:", error.message);
    }
    
    // Verificar Claude
    try {
      const claudeResponse = await axios.post(
        'https://api.anthropic.com/v1/messages',
        {
          model: "claude-3-haiku-20240307",
          max_tokens: 10,
          messages: [{ role: "user", content: "Test" }]
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': process.env.CLAUDE_API_KEY,
            'anthropic-version': '2023-06-01'
          }
        }
      );
      results.claude = !!claudeResponse.data;
    } catch (error) {
      console.error("Error verificando API key de Claude:", error.message);
    }
    
    results.allValid = results.openai && results.gemini && results.claude;
    return results;
  }
}

// Exportar una instancia del servicio
module.exports = new AIService();
```

### 2. Modificar el Controlador de Outfits

Ahora vamos a actualizar el controlador para utilizar nuestro servicio híbrido:

```javascript
// server/controllers/outfitController.js
const multer = require('multer');
const aiService = require('../services/aiService');
const userService = require('../services/userService'); // Asumimos que tienes un servicio de usuario

// Configuración de multer para la carga de imágenes
const storage = multer.memoryStorage();
const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // Límite de 5MB
  }
});

// Middleware de multer para subida de archivos
const uploadMiddleware = upload.single('image');

// Controlador para la generación de outfits
async function generateOutfits(req, res) {
  try {
    const { userId, occasion } = req.body;
    
    // Validar que tenemos una imagen
    if (!req.file || !req.file.buffer) {
      return res.status(400).json({
        success: false,
        error: 'No se ha proporcionado ninguna imagen'
      });
    }
    
    // 1. Obtener datos del usuario (o crear un perfil genérico si no existe)
    const userPreferences = userId 
      ? await userService.getUserPreferences(userId) 
      : {
          favoriteColors: ["Negro", "Azul", "Blanco"],
          favoriteStyles: ["Casual elegante", "Moderno"],
          occasions: ["Trabajo", "Casual", "Salida"],
          avoidedStyles: ["Demasiado llamativo"]
        };
    
    // 2. Analizar la imagen con Gemini (con fallback a OpenAI)
    console.log("Analizando imagen de prenda...");
    const garmentData = await aiService.analyzeGarmentImage(req.file.buffer);
    
    // 3. Analizar preferencias con Claude (con fallback a OpenAI)
    console.log("Analizando preferencias de estilo...");
    const stylePreferences = await aiService.analyzeUserStyle(userPreferences, occasion);
    
    // 4. Generar outfits con OpenAI
    console.log("Generando outfits...");
    const outfitResults = await aiService.generateOutfits(garmentData, stylePreferences);
    
    // 5. Devolver los resultados
    res.json({
      success: true,
      garmentData,
      stylePreferences,
      outfits: outfitResults.outfits || []
    });
    
  } catch (error) {
    console.error("Error en generación de outfits:", error);
    res.status(500).json({
      success: false,
      error: error.message || 'Error interno del servidor'
    });
  }
}

// Controlador para generación de contenido tipo revista
async function generateMagazine(req, res) {
  try {
    const { outfits, templateStyle } = req.body;
    
    if (!outfits || !Array.isArray(outfits) || outfits.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No se han proporcionado outfits válidos'
      });
    }
    
    if (!templateStyle) {
      return res.status(400).json({
        success: false,
        error: 'No se ha especificado un estilo de plantilla'
      });
    }
    
    // Generar contenido HTML de la revista
    const htmlContent = await aiService.generateMagazineContent(outfits, templateStyle);
    
    res.json({
      success: true,
      html: htmlContent
    });
    
  } catch (error) {
    console.error("Error en generación de revista:", error);
    res.status(500).json({
      success: false,
      error: error.message || 'Error interno del servidor'
    });
  }
}

// Verificar el estado de las API keys
async function checkApiStatus(req, res) {
  try {
    const status = await aiService.verifyApiKeys();
    res.json({
      success: true,
      status
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
}

module.exports = {
  uploadMiddleware,
  generateOutfits,
  generateMagazine,
  checkApiStatus
};
```

### 3. Actualizar las Rutas de la API

Ahora configuremos las rutas para nuestros nuevos controladores:

```javascript
// server/routes/api.js
const express = require('express');
const router = express.Router();
const outfitController = require('../controllers/outfitController');

// Ruta para verificar el estado de las APIs
router.get('/status', outfitController.checkApiStatus);

// Ruta para generación de outfits
router.post('/outfits/generate', 
  outfitController.uploadMiddleware,
  outfitController.generateOutfits
);

// Ruta para generación de revista
router.post('/magazine/generate', outfitController.generateMagazine);

module.exports = router;
```

### 4. Mejorar el Context Provider en el Frontend

Vamos a actualizar el `OutfitProvider` para trabajar con la nueva estructura de datos:

```jsx
// client/src/context/OutfitProvider.jsx
import React, { createContext, useContext, useState } from 'react';

// Tipos de datos (si usas TypeScript)
/*
interface GarmentData {
  type: string;
  color: string;
  style: string;
  material: string;
  occasions: string[];
  season: string;
}

interface StylePreference {
  styleElements: string[];
  colorPalette: string[];
  avoidStyles: string[];
  focusPoints: string[];
  rationale: string;
}

interface Outfit {
  id: number;
  name: string;
  items: string[];
  occasion: string;
  style: string;
  stylingTip: string;
}
*/

// Crear el contexto
const OutfitContext = createContext();

export function OutfitProvider({ children }) {
  const [garmentData, setGarmentData] = useState(null);
  const [stylePreferences, setStylePreferences] = useState(null);
  const [outfits, setOutfits] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [apiStatus, setApiStatus] = useState({
    checked: false,
    openai: false,
    gemini: false,
    claude: false,
    allValid: false
  });

  // Verificar el estado de las APIs
  const checkApiStatus = async () => {
    try {
      const response = await fetch('/api/status');
      const data = await response.json();
      
      if (data.success) {
        setApiStatus({
          checked: true,
          ...data.status
        });
      }
    } catch (err) {
      console.error('Error verificando API status:', err);
    }
  };

  // Cargar imagen y generar outfits
  const uploadImage = async (file, userId = null, occasion = null) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const formData = new FormData();
      formData.append('image', file);
      
      if (userId) {
        formData.append('userId', userId);
      }
      
      if (occasion) {
        formData.append('occasion', occasion);
      }
      
      const response = await fetch('/api/outfits/generate', {
        method: 'POST',
        body: formData,
      });
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Error generando outfits');
      }
      
      setGarmentData(data.garmentData);
      setStylePreferences(data.stylePreferences);
      setOutfits(data.outfits);
    } catch (err) {
      setError(err.message || 'Error inesperado');
      console.error('Error procesando imagen:', err);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Generar contenido de revista
  const generateMagazine = async (selectedOutfits, templateStyle) => {
    try {
      const response = await fetch('/api/magazine/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          outfits: selectedOutfits,
          templateStyle
        })
      });
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Error generando contenido de revista');
      }
      
      return data.html;
    } catch (err) {
      console.error('Error generando revista:', err);
      throw err;
    }
  };
  
  // Limpiar todos los datos
  const clearOutfits = () => {
    setOutfits([]);
    setGarmentData(null);
    setStylePreferences(null);
  };
  
  // Valores expuestos por el contexto
  const value = {
    garmentData,
    stylePreferences,
    outfits,
    isLoading,
    error,
    apiStatus,
    uploadImage,
    generateMagazine,
    clearOutfits,
    checkApiStatus
  };
  
  return (
    <OutfitContext.Provider value={value}>
      {children}
    </OutfitContext.Provider>
  );
}

// Hook personalizado para acceder al contexto
export function useOutfit() {
  const context = useContext(OutfitContext);
  if (!context) {
    throw new Error('useOutfit debe usarse dentro de un OutfitProvider');
  }
  return context;
}
```

### 5. Componente de Estado de las APIs

Vamos a crear un componente para mostrar el estado de las APIs:

```jsx
// client/src/components/ApiStatusIndicator.jsx
import React, { useEffect } from 'react';
import { useOutfit } from '../context/OutfitProvider';

export default function ApiStatusIndicator() {
  const { apiStatus, checkApiStatus } = useOutfit();
  
  useEffect(() => {
    if (!apiStatus.checked) {
      checkApiStatus();
    }
  }, [apiStatus.checked, checkApiStatus]);
  
  if (!apiStatus.checked) {
    return (
      <div className="bg-gray-100 p-3 rounded-lg mb-4 text-center">
        <p className="text-gray-600 text-sm">Verificando estado de los servicios de IA...</p>
      </div>
    );
  }
  
  const allValid = apiStatus.openai && apiStatus.gemini && apiStatus.claude;
  
  return (
    <div className={`p-3 rounded-lg mb-4 ${allValid ? 'bg-green-50' : 'bg-amber-50'}`}>
      <div className="flex items-center justify-between">
        <p className={`text-sm font-medium ${allValid ? 'text-green-800' : 'text-amber-800'}`}>
          Estado del Sistema Híbrido de IA
        </p>
        
        <div className="flex space-x-1">
          <div className={`px-2 py-1 rounded text-xs ${apiStatus.openai ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
            OpenAI
          </div>
          <div className={`px-2 py-1 rounded text-xs ${apiStatus.gemini ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
            Gemini
          </div>
          <div className={`px-2 py-1 rounded text-xs ${apiStatus.claude ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
            Claude
          </div>
        </div>
      </div>
      
      {!allValid && (
        <p className="text-xs text-amber-600 mt-2">
          {!apiStatus.openai && !apiStatus.gemini && !apiStatus.claude 
            ? 'No se pudo conectar con ningún servicio de IA. Verifica las claves API.'
            : 'Algunos servicios de IA no están disponibles. La aplicación funcionará con capacidad reducida.'}
        </p>
      )}
    </div>
  );
}
```

### 6. Modificar el Compon