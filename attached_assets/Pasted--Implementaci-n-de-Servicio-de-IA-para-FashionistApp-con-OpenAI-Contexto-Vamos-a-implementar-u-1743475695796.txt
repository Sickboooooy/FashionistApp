# Implementación de Servicio de IA para FashionistApp con OpenAI

## Contexto

Vamos a implementar un servicio de IA avanzado para FashionistApp que utilizará OpenAI para todas las funcionalidades, pero con una arquitectura que permita incorporar fácilmente otras APIs de IA (como Claude o Gemini) en el futuro cuando estén disponibles.

## Objetivo

Crear un sistema que permita:
1. Analizar imágenes de prendas para extraer características
2. Analizar preferencias de usuario para personalizar recomendaciones
3. Generar outfits completos basados en una prenda subida
4. Crear contenido editorial tipo revista

## Implementación: Paso a Paso

### 1. Crear el Servicio de IA

```javascript
// server/services/aiService.js
const { OpenAI } = require('openai');

class AIService {
  constructor() {
    // Inicializar cliente de OpenAI
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  /**
   * Analiza una imagen de prenda para extraer sus características
   * @param {Buffer} imageBuffer - Buffer de la imagen
   * @returns {Promise<Object>} - Datos estructurados de la prenda
   */
  async analyzeGarmentImage(imageBuffer) {
    console.log("Analizando imagen de prenda con OpenAI Vision...");
    try {
      const base64Image = imageBuffer.toString('base64');
      
      const response = await this.openai.chat.completions.create({
        model: "gpt-4-vision-preview",
        messages: [
          {
            role: "system",
            content: "Eres un experto en moda que analiza prendas de vestir con gran precisión. Proporciona detalles detallados y específicos."
          },
          {
            role: "user",
            content: [
              {
                type: "text",
                text: "Analiza esta prenda de ropa y proporciona los siguientes datos en formato JSON: tipo de prenda, color principal, estilo, material aparente, ocasiones apropiadas (array) y temporada. Responde SOLO con el JSON."
              },
              {
                type: "image_url",
                image_url: {
                  url: `data:image/jpeg;base64,${base64Image}`
                }
              }
            ]
          }
        ],
        max_tokens: 800
      });
      
      // Extraer el contenido
      const content = response.choices[0].message.content;
      
      try {
        // Intentar extraer JSON si está en formato código
        const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) || 
                         content.match(/```\n([\s\S]*?)\n```/) ||
                         content.match(/{[\s\S]*?}/);
                         
        const jsonData = jsonMatch 
          ? JSON.parse(jsonMatch[1] || jsonMatch[0]) 
          : { error: "No se pudo extraer JSON" };
          
        return jsonData;
      } catch (parseError) {
        console.error("Error parseando respuesta:", parseError);
        return {
          error: "Error procesando la respuesta",
          rawResponse: content
        };
      }
    } catch (error) {
      console.error("Error en análisis de imagen:", error);
      return {
        type: "No identificado",
        color: "No identificado",
        style: "Casual",
        material: "No identificado",
        occasions: ["Casual"],
        season: "All season",
        error: "Análisis fallido"
      };
    }
  }

  /**
   * Analiza preferencias de usuario para generar recomendaciones de estilo
   * @param {Object} userPreferences - Preferencias del usuario
   * @param {string} occasion - Ocasión para la que se requiere el outfit
   * @returns {Promise<Object>} - Análisis de estilo
   */
  async analyzeUserStyle(userPreferences, occasion = null) {
    console.log("Analizando estilo del usuario con OpenAI...");
    try {
      const response = await this.openai.chat.completions.create({
        model: "gpt-4-turbo",
        messages: [
          {
            role: "system",
            content: "Eres un estilista personal experto que analiza preferencias para crear recomendaciones personalizadas."
          },
          {
            role: "user",
            content: `Analiza las siguientes preferencias de usuario para generar recomendaciones de estilo${occasion ? ` para la ocasión "${occasion}"` : ''}.
            
            Preferencias del usuario:
            ${JSON.stringify(userPreferences, null, 2)}
            
            Devuelve un objeto JSON con:
            - styleElements: Array con los elementos de estilo clave a priorizar
            - colorPalette: Array con colores recomendados (nombres y códigos hex)
            - avoidStyles: Array con estilos a evitar
            - focusPoints: Array con puntos de enfoque para los outfits
            - rationale: Texto explicando el análisis realizado
            
            Responde ÚNICAMENTE con el objeto JSON, sin texto adicional.`
          }
        ],
        response_format: { type: "json_object" }
      });
      
      return JSON.parse(response.choices[0].message.content);
    } catch (error) {
      console.error("Error en análisis de estilo:", error);
      // Devolver datos genéricos en caso de error
      return {
        styleElements: ["Elegante", "Versátil", "Moderno"],
        colorPalette: ["Negro (#000000)", "Blanco (#FFFFFF)", "Azul marino (#000080)", "Beige (#F5F5DC)"],
        avoidStyles: ["Excesivamente casual", "Demasiado llamativo"],
        focusPoints: ["Silueta favorecedora", "Combinar con básicos"],
        rationale: "Recomendaciones genéricas basadas en principios universales de moda.",
        error: "Análisis fallido"
      };
    }
  }

  /**
   * Genera outfits completos basados en una prenda y preferencias
   * @param {Object} garmentData - Datos de la prenda analizada
   * @param {Object} stylePreferences - Preferencias de estilo
   * @param {number} count - Número de outfits a generar
   * @returns {Promise<Object>} - Outfits generados
   */
  async generateOutfits(garmentData, stylePreferences, count = 3) {
    console.log("Generando outfits con OpenAI...");
    try {
      const response = await this.openai.chat.completions.create({
        model: "gpt-4-turbo",
        messages: [
          {
            role: "system",
            content: "Eres un estilista de moda de élite que crea outfits personalizados basados en prendas y preferencias. Respondes siempre con JSON estructurado."
          },
          {
            role: "user",
            content: `Genera ${count} outfits completos basados en esta prenda:
            
            ${JSON.stringify(garmentData, null, 2)}
            
            Y considerando estas preferencias de estilo:
            
            ${JSON.stringify(stylePreferences, null, 2)}
            
            Devuelve un objeto JSON con un array 'outfits', donde cada elemento del array contiene:
            {
              "id": número único,
              "name": nombre creativo del outfit,
              "items": array con todas las prendas y accesorios (incluyendo la prenda original),
              "occasion": ocasión ideal,
              "style": estilo general,
              "stylingTip": consejo de estilismo
            }
            
            Asegúrate de que la respuesta sea SOLAMENTE un objeto JSON válido sin explicaciones adicionales.`
          }
        ],
        response_format: { type: "json_object" }
      });
      
      const result = JSON.parse(response.choices[0].message.content);
      return result;
    } catch (error) {
      console.error("Error generando outfits:", error);
      throw new Error(`Error generando outfits: ${error.message}`);
    }
  }
  
  /**
   * Genera contenido editorial tipo revista para los outfits
   * @param {Array} outfits - Outfits generados
   * @param {string} templateStyle - Estilo de la plantilla de revista
   * @returns {Promise<string>} - Contenido HTML para la revista
   */
  async generateMagazineContent(outfits, templateStyle) {
    console.log("Generando contenido editorial para revista...");
    try {
      const styleGuide = {
        'vogue': 'elegante, sofisticado, minimalista con lenguaje refinado',
        'elle': 'moderno, juvenil, dinámico con lenguaje accesible',
        'bazaar': 'lujoso, detallado con lenguaje poético y referencias artísticas',
        'vanity': 'audaz, dramático con lenguaje impactante',
        'custom': 'artesanal, personalizado con referencias a técnicas manuales y diseños únicos'
      };
      
      const response = await this.openai.chat.completions.create({
        model: "gpt-4",
        messages: [
          {
            role: "system",
            content: `Eres un editor de moda de élite para la revista ${templateStyle.toUpperCase()}. Creas contenido editorial sofisticado y elegante.`
          },
          {
            role: "user",
            content: `Crea un artículo editorial de moda de dos páginas basado en los siguientes outfits:
            
            ${JSON.stringify(outfits, null, 2)}
            
            El estilo editorial debe ser ${styleGuide[templateStyle] || 'elegante y sofisticado'}.
            
            Incluye:
            1. Un título impactante para el artículo
            2. Una introducción cautivadora
            3. Descripción editorial de cada outfit con lenguaje de revista de moda
            4. Consejos de accesorios y estilismo
            5. Un párrafo de cierre inspirador
            
            Formatea la respuesta en HTML con las siguientes secciones:
            <div class="magazine-title">TÍTULO</div>
            <div class="magazine-intro">INTRODUCCIÓN</div>
            <div class="outfit-section">
              <div class="outfit-number">Outfit X</div>
              <div class="outfit-description">DESCRIPCIÓN</div>
              <div class="styling-tips">CONSEJOS</div>
            </div>
            ... (repetir para cada outfit)
            <div class="magazine-closing">CIERRE</div>`
          }
        ],
        max_tokens: 1500
      });
      
      return response.choices[0].message.content;
    } catch (error) {
      console.error("Error generando contenido de revista:", error);
      throw new Error(`Error generando contenido editorial: ${error.message}`);
    }
  }
  
  /**
   * Verifica la disponibilidad de las APIs
   * @returns {Promise<Object>} - Estado de las APIs
   */
  async verifyApiStatus() {
    const results = {
      openai: false,
      allValid: false
    };
    
    console.log("Verificando estado de APIs...");
    
    // Verificar OpenAI
    try {
      const openaiResponse = await this.openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: "Test" }],
        max_tokens: 5
      });
      results.openai = !!openaiResponse.choices;
    } catch (error) {
      console.error("Error verificando OpenAI:", error.message);
    }
    
    // Estructura preparada para futuras APIs
    results.allValid = results.openai;
    return results;
  }
}

// Exportar una instancia del servicio
module.exports = new AIService();
```

### 2. Crear el Controlador para Outfits

```javascript
// server/controllers/outfitController.js
const multer = require('multer');
const aiService = require('../services/aiService');

// Configuración de multer para la carga de imágenes
const storage = multer.memoryStorage();
const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // Límite de 5MB
  }
});

// Middleware de multer para subida de archivos
const uploadMiddleware = upload.single('image');

// Controlador para la generación de outfits
async function generateOutfits(req, res) {
  try {
    const { userId, occasion } = req.body;
    
    // Validar que tenemos una imagen
    if (!req.file || !req.file.buffer) {
      return res.status(400).json({
        success: false,
        error: 'No se ha proporcionado ninguna imagen'
      });
    }
    
    // Crear un perfil genérico si no hay userId
    const userPreferences = {
      favoriteColors: ["Negro", "Azul", "Blanco"],
      favoriteStyles: ["Casual elegante", "Moderno"],
      occasions: ["Trabajo", "Casual", "Salida"],
      avoidedStyles: ["Demasiado llamativo"]
    };
    
    // 1. Analizar la imagen con OpenAI Vision
    console.log("Analizando imagen de prenda...");
    const garmentData = await aiService.analyzeGarmentImage(req.file.buffer);
    
    // 2. Analizar preferencias con OpenAI
    console.log("Analizando preferencias de estilo...");
    const stylePreferences = await aiService.analyzeUserStyle(userPreferences, occasion);
    
    // 3. Generar outfits con OpenAI
    console.log("Generando outfits...");
    const outfitResults = await aiService.generateOutfits(garmentData, stylePreferences);
    
    // 4. Devolver los resultados
    res.json({
      success: true,
      garmentData,
      stylePreferences,
      outfits: outfitResults.outfits || []
    });
    
  } catch (error) {
    console.error("Error en generación de outfits:", error);
    res.status(500).json({
      success: false,
      error: error.message || 'Error interno del servidor'
    });
  }
}

// Controlador para generación de contenido tipo revista
async function generateMagazine(req, res) {
  try {
    const { outfits, templateStyle } = req.body;
    
    if (!outfits || !Array.isArray(outfits) || outfits.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No se han proporcionado outfits válidos'
      });
    }
    
    if (!templateStyle) {
      return res.status(400).json({
        success: false,
        error: 'No se ha especificado un estilo de plantilla'
      });
    }
    
    // Generar contenido HTML de la revista
    const htmlContent = await aiService.generateMagazineContent(outfits, templateStyle);
    
    res.json({
      success: true,
      html: htmlContent
    });
    
  } catch (error) {
    console.error("Error en generación de revista:", error);
    res.status(500).json({
      success: false,
      error: error.message || 'Error interno del servidor'
    });
  }
}

// Verificar el estado de las API keys
async function checkApiStatus(req, res) {
  try {
    const status = await aiService.verifyApiStatus();
    res.json({
      success: true,
      status
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
}

module.exports = {
  uploadMiddleware,
  generateOutfits,
  generateMagazine,
  checkApiStatus
};
```

### 3. Configurar las Rutas API

```javascript
// server/routes/api.js
const express = require('express');
const router = express.Router();
const outfitController = require('../controllers/outfitController');

// Ruta para verificar el estado de las APIs
router.get('/status', outfitController.checkApiStatus);

// Ruta para generación de outfits
router.post('/outfits/generate', 
  outfitController.uploadMiddleware,
  outfitController.generateOutfits
);

// Ruta para generación de revista
router.post('/magazine/generate', outfitController.generateMagazine);

module.exports = router;
```

### 4. Actualizar la Configuración del Servidor

```javascript
// server/index.js
const express = require('express');
const path = require('path');
const dotenv = require('dotenv');
const apiRoutes = require('./routes/api');

// Cargar variables de entorno
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Configurar CORS para desarrollo local
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  next();
});

// Servir archivos estáticos desde la carpeta client/build si existe
try {
  const staticPath = path.join(__dirname, '../client/build');
  if (require('fs').existsSync(staticPath)) {
    app.use(express.static(staticPath));
    console.log('Serving static files from:', staticPath);
  }
} catch (err) {
  console.log('Static path not found, skipping...');
}

// Rutas de API
app.use('/api', apiRoutes);

// Ruta de verificación
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Ruta catch-all para SPA (si existe client/build)
try {
  const indexPath = path.join(__dirname, '../client/build/index.html');
  if (require('fs').existsSync(indexPath)) {
    app.get('*', (req, res) => {
      res.sendFile(indexPath);
    });
    console.log('SPA mode enabled with:', indexPath);
  }
} catch (err) {
  console.log('SPA index not found, skipping catch-all route');
}

// Iniciar servidor
app.listen(PORT, () => {
  console.log(`Servidor corriendo en http://localhost:${PORT}`);
  console.log('Modo:', process.env.NODE_ENV || 'development');
});
```

### 5. Actualizar el Context Provider de Frontend

```jsx
// client/src/context/OutfitProvider.jsx
import React, { createContext, useContext, useState } from 'react';

// Crear el contexto
const OutfitContext = createContext();

export function OutfitProvider({ children }) {
  const [garmentData, setGarmentData] = useState(null);
  const [stylePreferences, setStylePreferences] = useState(null);
  const [outfits, setOutfits] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [apiStatus, setApiStatus] = useState({
    checked: false,
    openai: false,
    allValid: false
  });

  // Verificar el estado de las APIs
  const checkApiStatus = async () => {
    try {
      const response = await fetch('/api/status');
      const data = await response.json();
      
      if (data.success) {
        setApiStatus({
          checked: true,
          ...data.status
        });
      }
    } catch (err) {
      console.error('Error verificando API status:', err);
    }
  };

  // Cargar imagen y generar outfits
  const uploadImage = async (file, userId = null, occasion = null) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const formData = new FormData();
      formData.append('image', file);
      
      if (userId) {
        formData.append('userId', userId);
      }
      
      if (occasion) {
        formData.append('occasion', occasion);
      }
      
      const response = await fetch('/api/outfits/generate', {
        method: 'POST',
        body: formData,
      });
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Error generando outfits');
      }
      
      setGarmentData(data.garmentData);
      setStylePreferences(data.stylePreferences);
      setOutfits(data.outfits);
    } catch (err) {
      setError(err.message || 'Error inesperado');
      console.error('Error procesando imagen:', err);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Generar contenido de revista
  const generateMagazine = async (selectedOutfits, templateStyle) => {
    try {
      const response = await fetch('/api/magazine/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          outfits: selectedOutfits,
          templateStyle
        })
      });
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Error generando contenido de revista');
      }
      
      return data.html;
    } catch (err) {
      console.error('Error generando revista:', err);
      throw err;
    }
  };
  
  // Limpiar todos los datos
  const clearOutfits = () => {
    setOutfits([]);
    setGarmentData(null);
    setStylePreferences(null);
  };
  
  // Valores expuestos por el contexto
  const value = {
    garmentData,
    stylePreferences,
    outfits,
    isLoading,
    error,
    apiStatus,
    uploadImage,
    generateMagazine,
    clearOutfits,
    checkApiStatus
  };
  
  return (
    <OutfitContext.Provider value={value}>
      {children}
    </OutfitContext.Provider>
  );
}

// Hook personalizado para acceder al contexto
export function useOutfit() {
  const context = useContext(OutfitContext);
  if (!context) {
    throw new Error('useOutfit debe usarse dentro de un OutfitProvider');
  }
  return context;
}
```

### 6. Componente de Estado de API

```jsx
// client/src/components/ApiStatusIndicator.jsx
import React, { useEffect } from 'react';
import { useOutfit } from '../context/OutfitProvider';

export default function ApiStatusIndicator() {
  const { apiStatus, checkApiStatus } = useOutfit();
  
  useEffect(() => {
    if (!apiStatus.checked) {
      checkApiStatus();
    }
  }, [apiStatus.checked, checkApiStatus]);
  
  if (!apiStatus.checked) {
    return (
      <div className="bg-gray-100 p-3 rounded-lg mb-4 text-center">
        <p className="text-gray-600 text-sm">Verificando estado de los servicios de IA...</p>
      </div>
    );
  }
  
  return (
    <div className={`p-3 rounded-lg mb-4 ${apiStatus.openai ? 'bg-green-50' : 'bg-amber-50'}`}>
      <div className="flex items-center justify-between">
        <p className={`text-sm font-medium ${apiStatus.openai ? 'text-green-800' : 'text-amber-800'}`}>
          Estado del Sistema de IA
        </p>
        
        <div className="flex space-x-1">
          <div className={`px-2 py-1 rounded text-xs ${apiStatus.openai ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
            OpenAI
          </div>
        </div>
      </div>
      
      {!apiStatus.openai && (
        <p className="text-xs text-amber-600 mt-2">
          No se pudo conectar con OpenAI. Verifica la clave API.
        </p>
      )}
    </div>
  );
}
```

## Instrucciones de Implementación

1. Instala las dependencias necesarias:
   ```bash
   npm install axios dotenv multer @emotion/react @emotion/styled
   ```

2. Asegúrate de que la variable de entorno OPENAI_API_KEY esté configurada correctamente en Replit

3. Implementa primero el servicio de IA y el controlador

4. Luego configura las rutas API

5. Finalmente, actualiza el frontend para utilizar la nueva funcionalidad

### Estructura preparada para el futuro

Este código está estructurado para que puedas incorporar fácilmente Gemini y Claude en el futuro. Cuando tengas las claves API correspondientes, solo necesitarás:

1. Añadir las claves a los secretos de Replit
2. Implementar los métodos específicos en el AIService
3. Actualizar el método verifyApiStatus para comprobar todas las APIs

Con esta implementación, ya tendrás una aplicación completamente funcional que utiliza OpenAI para todas las tareas de IA, con una arquitectura preparada para expandirse en el futuro.